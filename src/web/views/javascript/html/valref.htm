<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=gb2312">
<TITLE>复制、传递和比较数据</TITLE>
<!--CSS_START-->
<style>@import url(../html-vss/msdnie4a.css);</style>
<link disabled rel="stylesheet" href="../html-vss/msdn_ie3.css">
<!--CSS_END-->
</HEAD>
<BODY>


<!--Start Head-->
<TABLE class="banner" width="100%" CELLSPACING=0>
<TR>
<TD class="bannerleft" nowrap>JScript&nbsp;</TD>
<TD class="bannerright" nowrap><a href="../html-vss/jsTOC.htm">语言参考</a></TD>
</TR>
</TABLE>
<HR>
<!--End Head-->

<H1><A NAME="valref"></A>复制、传递和比较数据</H1>

<P>在 JScript 中，对数据的处理取决于该数据的类型。 </P>

<H2>按值和按引用的比较</H2>

<P>Numbers 和 Boolean 类型的值 (<B>true</B> 和 <B>false</B>) 是按值来复制、传递和比较的。当按值复制或传递时，将在计算机内存中分配一块空间并将原值复制到其中。然后，即使更改原来的值，也不会影响所复制的值（反过来也一样），因为这两个值是独立的实体。</P>

<P>对象、数组以及函数是按引用来复制、传递和比较的。 当按地址复制或传递时，实际是创建一个指向原始项的指针，然后就像拷贝一样来使用该指针。如果随后更改原始项，则将同时更改原始项和复制项（反过来也一样）。实际上只有一个实体；“复本”并不是一个真正的复本，而只是该数据的又一个引用。</P>

<P>当按引用比较时，要想比较成功，两个变量必须参照完全相同的实体。例如，两个不同的 <B>Array</B> 对象即使包含相同的元素也将比较为不相等。要想比较成功，其中一个变量必须为另一个的参考。要想检查两个数组是否包含了相同的元素，比较 <B>toString()</B> 方法的结果。</P>

<P>最后，字符串是按引用复制和传递的，但是是按值来比较的。请注意，假如有两个 <B>String</B> 对象（用 <B>new</B> String("something") 创建的），按引用比较它们，但是，如果其中一个或者两者都是字符串值的话，按值比较它们。</P>

<P class=indent><B>注意&nbsp;&nbsp;&nbsp;</B>鉴于 <A HREF="glossary.htm#defasciijs">ASCII</A>和 ANSI 字符集的构造方法，按序列顺序大写字母位于小写字母的前面。例如 "Zoo" 小于 "aardvark"。如果想执行不区分大小写的匹配，可以对两个字符串调用 <B>toUpperCase()</B> 或 <B>toLowerCase()</B>。</P>

<H2>传递参数给函数</H2>

<P>按值传递一个参数给函数就是制作该参数的一个独立复本，即一个只存在于该函数内的复本。即使按引用传递对象和数组时，如果直接在函数中用新值覆盖原先的值，在函数外并不反映新值。只有在对象的属性或者数组的元素改变时，在函数外才可以看出。</P>

<P>例如（使用 IE 对象模式）：</P>

<PRE><CODE>// </CODE>本代码段破坏（覆盖）其参数，所以
<CODE>// </CODE>调用代码中反映不出变化。
<CODE>function Clobber(param) </CODE>
{
<CODE>    // </CODE>破坏参数；在调用代码中
<CODE>    // </CODE>看不到。
<CODE>    param = new Object();</CODE>
<CODE>    param.message = "This will not work";</CODE>
}

<CODE>// </CODE>本段代码改变参数的属性，
<CODE>// </CODE>在调用代码中可看到属性改变。
<CODE>function Update(param)</CODE>
{
<CODE>    // </CODE>改变对象的属性；
<CODE>    // </CODE>可从调用代码中看到改变。
<CODE>    param.message = "I was changed";</CODE>
}

<CODE>// </CODE>创建一个对象，并赋给一个属性。
<CODE>var obj = new Object();</CODE>
<CODE>obj.message = "This is the original";</CODE>

<CODE>// </CODE>调用<CODE> Clobber</CODE>，并输出<CODE> obj.message</CODE>。注意，它没有发生变化。
<CODE>Clobber(obj);</CODE>
<CODE>window.alert(obj.message); // </CODE>仍然显示<CODE> "This is the original"</CODE>。

<CODE>// </CODE>调用<CODE> Update</CODE>，并输出<CODE> obj.message</CODE>。注意，它已经被改变了。
<CODE>Update(obj);</CODE>
<CODE>window.alert(obj.message); // </CODE>显示<CODE> "I was changed"</CODE>。</PRE>

<H2>检验数据</H2>

<P>当按值进行检验时，是比较两个截然不同的项以查看它们是否相等。通常，该比较是逐字节进行的。当按引用进行检验时，是看这两项是否是指向同一个原始项的指针。如果是，则比较结果是相等；如果不是，即使它们每个字节都包含完全一样的值，比较结果也为不相等。</P>

<P>按引用复制和传递字符串能节约内存；但是由于在字符串被创建后不能进行更改，因此可以按值进行比较。这样可以检查两个字符串是否包含相同的内容，即使它们是完全独立产生的。</P>
<!--Copyright_START-->
<DIV CLASS="footer">
<HR><a href="jscopy.htm">&copy; 2000 Microsoft Corporation 版权所有。保留所有权利。使用规定。</a><br>
</DIV> <!--Copyright_END-->

</BODY>
</HTML>
